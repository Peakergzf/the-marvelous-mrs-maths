"""
Permutations

1. Conversions between different notations for permutations.
2. Composition of permutations.
3. Cyclic subgroup in the Symmetric group Sn.

Note on notations for permutations:
1. one-line notation:
    since perm is a bijection from {1..n} to {1..n} but python list uses zero based index,
    we set perm[0] to be always -1.
    e.g. perm = [-1, 6, 5, 3, 7, 1, 2, 4]
         perm maps i to perm[i] for all 1 <= i <= n.
2. disjoint cycle notation:
    although "loners" (cycle of length 1) can be ignored, we always include them
    e.g. perm = [[1, 6, 2, 5], [4, 7], [3]]
         in each cycle perm maps cyc[i] to cyc[(i + 1) % cyc_len].
"""


def enough_nums_cyc(perm, n):
    """
    check if the given permutation in disjoint cycle notation in Sn maps n numbers
    """
    tot_len = 0
    for cyc in perm:
        tot_len += len(cyc)
    return tot_len == n


def cyc_to_line(perm, n):
    """
    convert from disjoint cycle to one-line notation
    :param perm: a permutation in disjoint cycle notation
    :param n: Sn
    :return: the converted permutation in one-line notation
    e.g.
    from [[1, 6, 2, 5], [4, 7], [3]] to [-1, 6, 5, 3, 7, 1, 2, 4]
    """
    assert enough_nums_cyc(perm, n)
    ans = [-1 for _ in range(n + 1)]
    for cyc in perm:
        for i in range(len(cyc)):
            ans[cyc[i]] = cyc[(i + 1) % len(cyc)]
    return ans


def line_to_cyc(perm, n):
    """
    convert from one-line to disjoint cycle notation
    :param perm: a permutation in one-line notation
    :param n: Sn
    :return: the converted permutation in disjoint cycle notation
    e.g.
    from [-1, 6, 5, 3, 7, 1, 2, 4] to [[1, 6, 2, 5], [4, 7], [3]]
    """

    assert len(perm) == n + 1

    # the permutation in disjoint cycle notation
    ans = []

    # current index in perm;
    # perm maps from idx to perm[idx],
    # idx and perm[idx] are the two adjacent numbers in a cycle
    idx = 1

    # current cycle
    cyc = [1]

    # seen[i] = True if i is already in ans, False otherwise
    seen = [False for _ in range(n + 1)]
    seen[1] = True

    while not enough_nums_cyc(ans, n):
        # if there are still numbers in the current cycle
        if perm[idx] not in cyc:
            cyc.append(perm[idx])
            seen[perm[idx]] = True
            idx = perm[idx]
        # if the current cycle is complete (i.e. cycle back to the first number in the cycle)
        else:
            ans.append(cyc)
            # find the next unseen(unmapped) number
            for i in range(1, n + 1):
                if not seen[i]:
                    idx = i
                    break
            cyc = [idx]
            seen[idx] = True

    return ans


def id_perm(n):
    """
    :return: the identity in Sn in one-line notation [-1, 1, 2, ..., n]
    """
    return [-1] + [i for i in range(1, n + 1)]


def comp_perm(sgm, tau, n):
    """
    compose two permutations sigma and tau in Sn in one-line notation
    (sgm.tau means "do tau first, then do sgm")
    e.g.
    if sgm = [3 1 2] and tau = [2 1 3]
    then 1 2 3 --tau--> 2 1 3 --sgm--> 1 3 2
    so sgm.tau = [1 3 2]
    """
    ans = [-1 for _ in range(n + 1)]
    for i in range(1, n + 1):
        ans[i] = sgm[tau[i]]
    return ans


def cyc_sub(perm, n):
    """
    prints the elements in the cyclic subgroup generated by perm in Sn
    :return: the order of perm
    """
    perm = cyc_to_line(perm, n)
    cur = perm
    subgroup = [line_to_cyc(cur, n)]
    # keep composing perm with itself until get the identity
    while cur != id_perm(n):
        cur = comp_perm(cur, perm, n)
        subgroup.append(line_to_cyc(cur, n))
    for elem in subgroup:
        print(elem)
    # the order of perm is the order of <perm> (# of elements in <perm>)
    return len(subgroup)


def main():
    print(cyc_sub([[1, 3, 4], [2, 6], [5]], 6))


if __name__ == '__main__':
    main()
